<h1 align="center">
  Ledger
</h1>

<p align="center">
  <img width="250px" height="auto" src="https://traent.com/wp-content/uploads/2022/07/logo-color.svg">
</p>

<br />

The Ledger library is contained in the `Ledger` project.
Unit testing of the library are in the `Ledger.Test` project.

### Table of Contents
**[Initialize the ledger](#initialize-the-ledger)**<br>
**[Create a new ledger](#create-a-new-ledger)**<br>
**[Policy](#policy)**<br>
**[Load an existing ledger](#load-an-existing-ledger)**<br>
**[Writing](#writing)**<br>
**[Reading](#reading)**<br>
**[Datablock hashes](#datablock-hashes)**<br>
**[DataAccessPlugins](#dataaccessplugins)**<br>
**[CryptographyPlugins](#cryptographyplugins)**<br>
**[Dry-run write operations](#dry-run-write-operations)**<br>
**[Dry-run create operation](#dry-run-create-operation)**<br>
**[Validity](#validity)**<br>
**[Testing](#testing)**<br>

## Initialize the ledger
Initializing a Ledger using all the default settings can be done by the following code:
```C#
using Traent.Ledger;
Ledger ledger = new Ledger();
```

The constructor expects a single optional input `PartialDefaultConfiguration` object, with the following possible properties:
* **DataAccessPlugin**: optional, an instance implementing `IDataAccessPlugin`. When not specified, an instance of the `InMemory` DataAccessPlugin will be used.
* **SupportDataAccessPlugin**: optional, an instance implementing `ISupportDataAccessPlugin`. When not specified, an instance of the `InMemorySupport` SupportDataAccessPlugin will be used.
* **CryptographyPlugin**: optional, an instance implementing `ICryptographyPlugin`. When not specified, an instance of `CryptographyPlugin.NaCl` will be used.
* **Encrypt**: optional, a boolean specifying if all the datablocks that will be written must be encripted. **When not specified, it's set to `true`**.

example:
```C#
using Traent.Ledger;
Ledger ledger = new Ledger(new PartialDefaultConfiguration() {
    DataAccessPlugin = new LocalFilesystem(),
    SupportDataAccessPlugin = new LocalFilesystemSupport(),
    CryptographyPlugin = new CryptographyPlugin.NaCl(),
    Encrypt = true,
});
```

## Create a new ledger:
Creating a new Ledger using all the default settings can be done by the following code:
```C#
Ledger ledger = new Ledger();
ledger.Create();
```

When creating a new Ledger, a cryptographic key pair will be automatically generated by the default CryptographyPlugin. The keys can be read after the creation:
```C#
Ledger ledger = new Ledger();
ledger.Create();
byte[] publicKey = ledger.Configuration.PublicKey;
byte[] secretKey = ledger.Configuration.SecretKey;
string publicKeyHumanReadable = ledger.Configuration.Policy.PublicKey;
```

Alternatively, it's possible to specify an existing key pair instead of creating a new one.
```C#
Ledger ledger = new Ledger();
KeyPair preExistingKeys = (new CryptographyPlugin.NaCl()).GenerateKey();
ledger.Create(preExistingKeys: preExistingKeys);
```

## Policy

Every Ledger has a policy (`ledger.Configuration.Policy`), composed by several properties:
* **Version**: a string, specifying the structure version (`"0.0"` is the current default value)
* **EncryptionAlgorithm**: a string, specifying the algorithm used to encrypt/decrypt data (currently only `"x25519-xsalsa20-poly1305"`, the default value, is supported)
* **SigningAlgorithm**: a string, specifying the algorithm used to sign data and to verify signatures (currently only `"ed25519"`, the default value, is supported)
* **HashingAlgorithm**: a string, specifying the algorithm used to compute cryptographical hashes (currently only `"SHA-512"`, the default value, is supported)
* **EncapsulationMethod**: an EncapsulationMethod enum value, specifying the encapsulation algorithm
  * `OnlyMoreExternalEncapsulationCodeIsSeparatedFromThePayload`: only the most external encapsulation code is always plaintext because, during the various operation processing steps, the current most external encapsulation code is processed as part of the payload, before appending the new most external encapsulation code. This option is the most secure one, because when processing an encryption operation, all the previous encapsulation data is truly inaccessible without the ledger secret key. The downside is that in case of a prebaked block write operation, without the ability to unencrypt it, it will be impossible to enforce any policy that needs to know the datablock structure.
  * `AllEncapsulationCodesAreSeparatedFromThePayload`: (the default value) all the encapsulation codes are always plaintext because, during the various operation processing steps, the list of encapsulation codes is not processed as part of the payload. This option will always expose the encapsulation structure of the datablock, even for encrypted datablocks. The advantage is that in case of a prebaked block write operation it will be possible to enforce a wide range of policies even when the ledger secret key is unknown.
* **SignAfterEncryption**: when `true` (the default value), the signing operation will be processed after the encryption, otherwise the signature will be encrypted too. Encrypting the signature is more secure, hiding all the information to everyone not in possess of the secret key, the downside is that that in case of a prebaked block write operation, it will be impossible to validate the signature.
* **EnforceEncryption**: optional, a string, specifying an encryption enforcement policy
  * `"always"`: all the datablocks must be encrypted, when not explicitly forbidden by the datablock type (for example, the initial policy block)
  * `"never"`: encryption is forbidden (with the exception of the initial policy block that must be plaintext, all the other datablock types requiring encryption, as the disclose block, cannot be written in this ledger)
* **EnforceSigning**: optional, a string, specifying a signing enforcement policy
  * `"always"`: all the datablocks must be signed, when not explicitly forbidden by the datablock type (for example, the initial policy block)
  * `"never"`: signing is forbidden
* **Authors**: optional, an array of public keys in byte[] format.
* **AllowedSignatures**: optional, a string, specifying when a signature is allowed
  * `"onlyAuthors"`: a signature is allowed only if the policy Authors list contains the signature public key
  * `"all"`: all signatures are allowed (this is the default behaviour when AllowedSignatures is not defined)
* **AllowAddAuthorBlocks**: optional, a boolean, specifying if the authors list can be extended after creation (`true`) of if it's fixed as specified in the genesis block (`false`, the default value). By setting `AllowAddAuthorBlocks` to `true`, the actual authors list is not known by just reading the genesis block, instead it will be necessary to scan and process all the blocks. A support authors list cache is managed by the data access plugin to improve performance, but in general `AllowAddAuthorBlocks` should not be set to `true` unless strictly needed.

The default policy can be overridden and extended at creation time:
```C#
Ledger ledger = new Ledger();
ledger.Create(new PartialPolicy() {
    Encapsulation = EncapsulationMethod = EncapsulationMethod.AllEncapsulationCodesAreSeparatedFromThePayload,
    SignAfterEncryption = false,
    EnforceEncryption = "always",
});
```

There are some constrains for the possible values of the policy:
* `AllowedSignatures` can be set equal to `"onlyAuthors"` only when `Authors` is defined
* if `AllowAddAuthorBlocks` is true, `AllowedSignatures` must be set equal to `"onlyAuthors"`
* if `AllowAddAuthorBlocks` is true, `EncapsulationMethod` must be set equal to `AllEncapsulationCodesAreSeparatedFromThePayload`

## Load an existing ledger

Loading an existing Ledger can be done by the following code:
```C#
Ledger ledger = new Ledger();
ledger.Load("ledgerpublickeystringformat");
```

The policy will be automatically set to the one found in the loaded ledger.

If the ledger cryptographic key pair is known, you need to pass it at loading time in order to be able to decrypt encrypted blocks when reading them:
```C#
Ledger ledger = new Ledger();
ledger.Load("ledgerpublickeystringformat", preExistingKeys);
```

## Writing

Currently only a single write method has been implemented: `writeRaw`
```C#
Ledger ledger = new Ledger();
ledger.Create();
ledger.WriteRaw("xxx");
```

`writeRaw` requires at least one imput parameter, the `payload`, that must be a `string` or a `byte[]`, and then there are several possible optional parameters:
* **previousBlockHash**: optional, a string representing the previous datablock hash value. When not specified, the head datablock hash will be used instead.
* **encrypt**: optional, a boolean specifying if the datablock must be encripted. **When not specified, the encrypt property used at Ledger initialization will be used, that is set to `true` by default**.
* **signAs**: optional, a `KeyPair` struct, that will be used to sign the datablock. When not specified, the datablock will not be signed.

## Reading

Currently only a single read method has been implemented: `readBlock`
```C#
Ledger ledger = new Ledger();
ledger.Create();
byte[] policyBlockPayload = ledger.ReadBlock(0); // read the initial policy datablock
ledger.WriteRaw("xxx");
byte[] blockPayload = ledger.ReadBlock(1);
```

`readBlock` returns the payload of the read datablock as a `byte[]`.

`readBlock` requires at least one input parameter, that must be the index of the datablock to read (an `int`) or the hash value of the datablock to read (a `string`), and then there are several possible optional parameters:
* **secretKey**: optional, a string that will specify the secret key to use when an encrypted payload is found.
* **preserveEncapsulation**: optional, a boolean, when `true` the payload of the datablock will be returned without resolving any encapsulation. When not specified, all the encapsulations will be resolved, triggering an error when it will not be possible (for example, when resolving an encryption encapsulation without knowing the secretkey).

### Obtain the read block `previousBlockHash` property

It's possible to obtain the `previousBlockHash` property of the read datablock by adding an optional `out previousBlockHash` to the function call inputs:
```C#
Ledger ledger = new Ledger();
ledger.Create();
ledger.WriteRaw("xxx");
ledger.ReadBlock(1, out string previousBlockHash); // previousBlockHash is set equal to the hash of the genesis block
```

### Obtain the read block `encapsulationDatas`

When reading a datablock, it's possible to obtain the information of the encapsulation of the block by adding an optional `out encapsulationDatas` to the function call inputs:
```C#
Ledger ledger = new Ledger();
KeyPair authorKey = (new CryptographyPlugin.NaCl()).GenerateKey();
ledger.Create();
ledger.WriteRaw("xxx", signAs: authorKey);
ledger.ReadBlock(1, out System.Collections.Generic.List<EncapsulationData> encapsulationDatas);
// encapsulationDatas.Count == 3
// encapsulationDatas[0].EncapsulationCode == EncapsulationCode.Signed
// encapsulationDatas[1].EncapsulationCode == EncapsulationCode.Encrypted
// encapsulationDatas[2].EncapsulationCode == EncapsulationCode.Raw
// ((EncapsulationDataSignature)encapsulationDatas[0]).PublicKey == authorKey.publicKey
```

The last `EncapsulationData` `EncapsulationCode` is always a final one (the ones listed in `Encapsulation.FinalEncapsulationCode`), and it can be used to check if the block is structural (the case of `EncapsulationCode.Policy` and `EncapsulationCode.AddAuthor`) or data (the case of `EncapsulationCode.Raw`).

## Add an author

If `AllowAddAuthorBlocks` is set to `true` in the ledger policy, then it's possible to add a new public key to the authors list, using the `AddAuthor` method:
```C#
Ledger ledger = new Ledger(new PartialDefaultConfiguration() {
    DataAccessPlugin = new LocalFilesystem(),
    SupportDataAccessPlugin = new LocalFilesystemSupport(),
});
KeyPair initialAuthorKey = (new CryptographyPlugin.NaCl()).GenerateKey();
ledger.Create(new PartialPolicy() {
    Authors = new byte[][] { initialAuthorKey.publicKey },
    AllowAddAuthorBlocks = true,
    AllowedSignatures = "onlyAuthors",
});
KeyPair newAuthorKey = (new CryptographyPlugin.NaCl()).GenerateKey();
ledger.AddAuthor(newAuthorKey.publicKey, signAs: initialAuthorKey);
```

The block added with `AddAuthor` must be signed using a key that is already contained in the authors list.

A prebaked `AddAuthor` block can be generated with:
```C#
ledger.AddAuthor(newAuthorKey.publicKey, signAs: initialAuthorKey, out DataBlock prebakedDataBlock, dryRun: true);
```

## Get authors list

By reading a ledger `Configuration.Policy.Authors` value, only the authors listed inside the genesis block are retrieved.

`GetExtendedAuthorsList` is a method that will return the current authors list, considering also the `AddAuthor` blocks:
```C#
System.Collections.Generic.List<byte[]> extendedAuthorsList = ledger.GetExtendedAuthorsList();
```

## Datablock hashes

An array with all the hases of the datablocks, in order, can be accessed by the following code:
```C#
Ledger ledger = new Ledger();
ledger.Create();
System.Collections.ObjectModel.ReadOnlyCollection<string> hashes = ledger.GetHashes();
hashes.Count; // 1 (the initial policy block)
ledger.WriteRaw("xxx");
ledger.WriteRaw("xxx");
hashes.Count; // 3 (the initial policy block)
```

## DataAccessPlugins
The DataAccessPlugins are used to serialize and deserialize the Ledgers.

### InMemory
This plugin will write the blocks in memory only, useful mainly for testing.

### LocalFilesystem
This plugin will serialize the Ledgers to the local filesystem.

The constructor expects a single optional argument:
* **workDirectory**: optional, a string specifying the local filesystem directory where all the Ledgers will be stored. When not specified, it's set to `"localFilesystemPluginStorage"`.

Every ledger will be stored in a distinct subdirectory of *workDirectory*.

example:
```C#
Ledger ledger = new Ledger(new PartialDefaultConfiguration() { DataAccessPlugin = new LocalFilesystem("myLocalStorageDirectory") });
ledger.Create();
```

## SupportDataAccessPlugins
The SupportDataAccessPlugins are used to serialize and deserialize generic support data rerlated to a specific ledger.

### InMemorySupport
This plugin will write the support data in memory only, useful mainly for testing.

### LocalFilesystemSupport
This plugin will serialize the support data to the local filesystem.

The constructor expects a single optional argument:
* **workDirectory**: optional, a string specifying the local filesystem directory where the support data will be stored. When not specified, it's set to `"localFilesystemSupportPluginStorage"`.

Every ledger support data will be stored in a distinct subdirectory of *workDirectory*.

example:
```C#
Ledger ledger = new Ledger(new PartialDefaultConfiguration() { SupportDataAccessPlugin = new LocalFilesystemSupport("myLocalSupportStorageDirectory") });
ledger.Create();
```

## CryptographyPlugins
The CryptographyPlugins are used to:
* key generation
* encrypt / decrypt
* signing / check signatures
* hashing

Currently only a single CryptographyPlugin has been implemented: `CryptographyPlugin.NaCl`.

### NaCl
Uses a custom binding to libsodium (https://libsodium.gitbook.io/doc/), that is based on the NaCl library (http://nacl.cr.yp.to/).

## Dry-run write operations

It's possible to execute a dry-run of all write methods. A dry-run call will execute all the usual processing (validation, policy checks, payload processing, encryption, signing, encapsulation, etc.) but will stop immediately before the step that will persist the block using the dataAccess plugin.

To execute a dry-run, the optional flag `dryRun` must be set to true:
```C#
Ledger ledger = new Ledger();
ledger.Create();
System.Collections.ObjectModel.ReadOnlyCollection<string> hashes = ledger.GetHashes();
hashes.Count; // 1 (the initial policy block)
ledger.WriteRaw("content", dryRun: true);
hashes.Count; // still 1
```

It's also possible to extract the prebaked datablock:
```C#
Ledger ledger = new Ledger();
ledger.Create();
ledger.WriteRaw("content", out DataBlock prebackedDataBlock, dryRun: true);
```

A dry-run execution could be used to test if an hypothetical write operation is valid, or to obtain a prebaked datablock to use in the future.

A prebaked datablock can be written to a ledger using the call `WritePrebakedBlock`:
```C#
ledger.WritePrebakedBlock(prebackedDataBlock.Payload.Span.ToArray(), prebackedDataBlock.PreviousBlockHash);
```

Depending on the encapsulation policy, the call `WritePrebakedBlock` can replicate some of the validation and policy checks on the prebaked datablock, even if the block payload is encrypted and the secret key is not known by the ledger instance.

A useful scenario for the dry-run write followed by `WritePrebakedBlock` is this one:
* `ledgerMaster` ledger instance knows the private key of the ledger
* `ledgerSlave` ledger is a replica of `ledgerMaster` that doesn't know the private key of the ledger
* `ledgerMaster` execute a dry-run write to produce a prebaked encrypted datablock
* the prebaked data block is written in `ledgerSlave` using `WritePrebakedBlock`

## Dry-run create operation

Analogously to the dry-run write operations, it's possible to make a dry-run of a ledger create operation. The operation will prepare a prebaked genesis datablock without creating the ledger.

To execute a dry-run, the optional flag `dryRun` must be set to true:
```C#
Ledger ledger = new Ledger();
ledger.IsLoaded(); // false
ledger.Create(dryRun: true);
ledger.IsLoaded(); // still false
```

It's also possible to extract the prebaked genesis datablock, and the used cryptographic key pair:
```C#
Ledger ledger = new Ledger();
ledger.Create(out DataBlock prebackedDataBlock, out KeyPair prebackedLedgerKeyPair, dryRun: true);
```

A prebaked genesis datablock can then be used to create a new ledger:
```C#
Ledger ledger = new Ledger();
ledger.Create(prebackedDataBlock.Payload.Span.ToArray(), System.Convert.ToBase64String(prebackedLedgerKeyPair.publicKey));
```

## Testing

Is possible to run all the unit tests with the following command:
```
dotnet test
```

## License

`ledger-dotnet` is available under the Apache-2 license. See the [LICENSE](./LICENSE) file for more info.

## Contributors

At the moment, contributions are not supported through Pull Request.
However, we truly appreciate any feedback made through the issue system.
